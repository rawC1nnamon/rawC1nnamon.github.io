---
title: "02 - Compiladores" 
description: "Explicaci√≥n y diferencias entre compilador e int√©rprete."
pubDate: "2025-4-17"
---

### Un poco de historia

Un computador funciona gracias a instrucciones ejecutadas por el procesador. 
Estas instrucciones est√°n escritas en binario, ya que es el √∫nico "lenguaje" 
que el procesador entiende, basado en se√±ales de voltaje.

En los primeros d√≠as de la inform√°tica, los programadores escrib√≠an directamente 
en binario o hexadecimal. Esto era propenso a errores, dif√≠cil de mantener y muy agotador,
por eso surgi√≥ el lenguaje ensamblador, una forma m√°s legible de escribir instrucciones, 
aunque segu√≠a siendo espec√≠fico para cada tipo de procesador. Con el tiempo, aparecieron los 
lenguajes de programaci√≥n de alto nivel, que facilitaron la escritura de programas y mejoraron 
la portabilidad entre diferentes sistemas. Pero esto llev√≥ a una pregunta clave: si el procesador 
solo entiende binario, ¬øc√≥mo se ejecuta un c√≥digo escrito en lenguaje humano?

### ¬øQu√© es compilar un programa?

Tras la problem√°tica anterior nacen los compiladores. Dejando de lado tanta ch√°chara, vamos al grano: 
¬øqu√© significa compilar un programa? Primero, no todos los lenguajes se compilan. Por ejemplo, Python 
y JavaScript son lenguajes interpretados. En cambio, lenguajes como C/C++, Rust o Go s√≠ se compilan. Cuando 
hablamos de "compilar", nos referimos al proceso de traducir el c√≥digo fuente a un archivo ejecutable que el 
procesador pueda entender, es decir, c√≥digo binario.

<p align="center"> <img src="/images/General/02-traductor.png" alt="02-traductor" width="600"/> </p>

Este proceso no es tan simple como parece. El compilador realiza varios pasos complejos, comenzando con 
el an√°lisis l√©xico y sem√°ntico. Usando teor√≠a matem√°tica y aut√≥matas, verifica que el c√≥digo tenga una sintaxis 
correcta y que tenga sentido dentro del contexto del lenguaje.

<p align="center"> <img src="/images/General/02-analisis.png" alt="02-analisis" width="800"/> </p>

Los siguientes pasos consisten en la generaci√≥n del c√≥digo intermedio (IR) y su optimizaci√≥n. Este c√≥digo 
intermedio es mucho m√°s digerible para el compilador que el original, lo que permite aplicar optimizaciones que 
hacen que el ejecutable final sea m√°s eficiente y liviano. Algunas de estas optimizaciones incluyen la eliminaci√≥n 
de c√≥digo muerto, advertencias sobre variables no utilizadas, entre otras, adem√°s, este c√≥digo es portable y est√° 
a un solo paso de convertirse en c√≥digo ensamblador.

Luego, el c√≥digo intermedio se transforma en c√≥digo ensamblador para la arquitectura objetivo. Con esto se llega a 
una de las √∫ltimas etapas del proceso: convertir ese ensamblador en un archivo objeto. Este archivo contiene instrucciones 
parciales de ejecuci√≥n, ya que a√∫n faltan por resolver algunas dependencias externas y las direcciones de memoria donde 
se almacenar√°n los recursos del programa.

<div style="display: flex; flex-wrap: wrap-reverse; align-items: flex-start;">
  
  <div style="flex: 1 1 300px; border-left: 4px solid #FFDE21; background-color: rgba(70, 130, 180, 0.1); color: #fff; padding: 1rem 1.25rem; margin: 1em 0; line-height: 1.6; font-size: 1rem; border-radius: 4px;">
    <strong>Advertencia:</strong><br>
    Esta tabla es una pseudorrepresentaci√≥n general de c√≥mo podr√≠a lucir la estructura de un archivo objeto. Digo 
    "pseudorrepresentaci√≥n" porque esta estructura var√≠a seg√∫n el sistema operativo, aunque el concepto general se 
    mantiene. Como puedes ver, el archivo est√° casi listo para convertirse en un ejecutable.
  </div>

  <img src="/images/General/02-objeto.png" alt="02-objeto" style="flex: 0 0 150px; width: 150px; margin: 1em 0 0 1em;" />
</div>

Finalmente, ¬°llegamos al √∫ltimo paso! Este consiste en enlazar (linkear) el archivo objeto con sus dependencias y otros 
archivos objeto. En esta etapa tambi√©n se resuelven las direcciones de memoria donde se almacenar√°n las funciones, variables 
y dem√°s recursos necesarios para la ejecuci√≥n del programa.

<p align="center"> <img src="/images/General/02-link.png" alt="02-link" width="600"/> </p>

### Instalando nuestro primer compilador

Bien, vamos a empezar con la parte did√°ctica: ¬°vamos a instalar nuestro primer compilador! En este caso, instalaremos el 
compilador de C, llamado GCC. En Linux, este ya viene instalado por defecto; en cambio, en Windows debemos instalarlo 
manualmente. Este viene incluido en el paquete MinGW, el cual podemos encontrar en SourceForge:
<a href="https://sourceforge.net/projects/mingw/" target="_blank">Descargar MinGW desde SourceForge</a>.
Tambi√©n puedes tomar este tutorial como referencia:
<a href="https://www.youtube.com/watch?v=GEZLjRSY_m8&t=9s" target="_blank">Instalaci√≥n de MinGW para compilar en C/C++ üë®üèª‚Äçüíª</a>.

Una vez instalado, abriremos nuestro editor de c√≥digo favorito y ¬°manos a la obra! Para empezar, vamos a probar una compilaci√≥n 
normal. Para ello, escribiremos un programa ‚ÄúHola mundo‚Äù y verificaremos c√≥mo se compila:

```c
#include <stdio.h>

int main() {
    printf("Hola mundo!\n");
    return 0;
}
```

Tras terminar de escribir nuestro c√≥digo, vamos a guardarlo y abrir nuestra terminal favorita. En mi caso, utilizo **Kitty** en 
Linux; si usas Windows, puedes usar **PowerShell**, **WezTerm** u otra terminal de tu preferencia. Para compilar nuestro programa, 
escribiremos el siguiente comando:

```
‚ùØ gcc <nombre>.c -o <nombre del ejecutable> 
```

Si todo sali√≥ correcto, obtendremos un archivo ejecutable con el nombre que le asignamos. El tipo de archivo ejecutable depender√° 
del sistema operativo, pero este tema lo abordaremos en una pr√≥xima clase. Ahora, vamos a ejecutar nuestro "Hola mundo" para verificar 
qu√© nos devuelve:

```
‚ùØ gcc main.c -o ejecutable
‚ùØ ./ejecutable
Hola mundo!
```

¬°Todo funcionando! Pero, ¬øpor qu√© obtenemos el ejecutable directamente? ¬øAcaso se salt√≥ los pasos anteriores? ¬°No! Simplemente realiza 
estos procesos sin mostr√°rselos al usuario. Aun as√≠, nosotros queremos ver el proceso. Bien, en primera instancia vamos a obtener el 
c√≥digo en ensamblador, para esto, asignamos el par√°metro **-S** antes del nombre de nuestro archivo **.c**:

```
‚ùØ gcc -S main.c -o ensamblador.asm
```
```asm
	.file	"main.c"
	.text
	.section	.rodata
.LC0:
	.string	"Hola mundo!"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
    ; ...
```

No se preocupen si no entienden ensamblador por ahora, solo estamos evidenciando el proceso. Ahora vamos a generar nuestro 
archivo objeto. Para esto, escribiremos el par√°metro **-c** antes del archivo **.c**:

```
‚ùØ gcc -c main.c -o objeto.o
```

El archivo objeto no lo podemos ver como tal. Para esto, debemos usar una herramienta especial llamada **objdump**. Esta viene 
instalada por defecto en Linux, y en Windows se incluye con MinGW. A trav√©s de esta herramienta, podemos inspeccionar las 
secciones de un archivo objeto. Por ejemplo, vamos a verificar la "**Section Header Table**" que evidenciamos en la tabla, para 
esto, escribiremos el par√°metro **-s** antes de nuestro archivo objeto **.o**:

```
‚ùØ objdump -s objeto.o
```
```asm
objeto.o:     file format elf64-x86-64

Contents of section .text:
 0000 554889e5 488d0500 00000048 89c7e800  UH..H......H....
 0010 000000b8 00000000 5dc3               ........].      
Contents of section .rodata:
 0000 486f6c61 206d756e 646f2100           Hola mundo!.    
Contents of section .comment:
 0000 00474343 3a202847 4e552920 31342e32  .GCC: (GNU) 14.2
 0010 2e312032 30323530 32303700           .1 20250207.    
Contents of section .note.gnu.property:
 0000 04000000 20000000 05000000 474e5500  .... .......GNU.
 0010 020001c0 04000000 01000000 00000000  ................
 0020 010001c0 04000000 01000000 00000000  ................
Contents of section .eh_frame:
 0000 14000000 00000000 017a5200 01781001  .........zR..x..
 0010 1b0c0708 90010000 1c000000 1c000000  ................
 0020 00000000 1a000000 00410e10 8602430d  .........A....C.
 0030 06550c07 08000000                    .U......        
```

Esto lo podemos hacer con cada secci√≥n del archivo objeto; basta con consultar los posibles par√°metros 
con **-h**. Procedamos con el √∫ltimo paso de nuestro ejemplo did√°ctico: linkear el archivo objeto. Este 
proceso es simple; es como compilar de manera tradicional, pero en vez del archivo **.c**, pasaremos el archivo 
objeto.

```
‚ùØ gcc objeto.o -o ejecutable 
‚ùØ ./ejecutable
Hola mundo!
```

### Diferencias entre compilador e int√©rprete

Para finalizar con esta entrada del blog, ya sabemos qu√© es un compilador, pero ahora bien, ¬øqu√© es un int√©rprete? 
La diferencia entre estos radica en c√≥mo se traducen las instrucciones al procesador. Mientras que un compilador 
genera un archivo ejecutable a partir del bloque de c√≥digo completo, un int√©rprete no genera un archivo ejecutable; 
m√°s bien, traduce a c√≥digo m√°quina l√≠nea por l√≠nea, por lo tanto, se ejecuta inmediatamente.

Esto tiene tanto desventajas como ventajas. Una de las m√°s grandes es el tiempo de ejecuci√≥n, puede sonar contradictorio, 
pero un lenguaje compilado es m√°s r√°pido que uno interpretado debido a que el trabajo pesado ya se hizo antes de que se 
ejecutara, mientras que un int√©rprete tiene que ejecutar y traducir a la vez. Sin embargo, un lenguaje interpretado puede 
llegar a ser m√°s flexible, ya que se puede modificar incluso en runtime.

| Lenguaje |         Tarea         |    Tiempo    |
|----------|-----------------------|--------------|
|    C     | Imprimir "hola mundo" | 2.45  millis |
|  Python  | Imprimir "hola mundo" | 21.67 millis | 
|    C     |   Contar hasta mil    | 6.38  millis |
|  Python  |   Contar hasta mil    | 27.72 millis |
